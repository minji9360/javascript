## 삽입 정렬의 핵심
각 숫자를 적절한 위치에 삽입한다.  
다른 정렬과 달리 필요할 때만 자리를 바꾼다.

## 예시
1 10 5 8 7 6 4 3 2 9
위 수를 오름차순으로 정렬하라

## 진행
1. 1은 정렬할 위치가 없음  
(1 앞에 숫자가 없으므로)
2. 10은 1보다 크기 때문에 위치 유지  
_ 1 _ 10 언더바 두 자리 중 한 군데에 들어갈 수 있음
3. 5는 1보다 크고 10보다 작기 때문에 해당 위치로 이동  
(10과 자리를 바꿈)  
_ 1 _ 10 _ 5 세 자리 중 한 군데에 들어갈 수 있음
이런 식으로 반복

## 구현
```c
int main(void)
{
	int i, j, temp;
	int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
	for (i = 0; i < 9; i++)
	{
		j = i;
		while (array[j] > array[j + 1])
		{
			temp = array[j];
			array[j] = array[j + 1];
			array[j + 1] = temp;
			j--;
		}
	}
	for (i = 0; i < 10; i++)
		printf("%d ", array[i]);
	return (0);
}
```
## 시간 복잡도 : O(N^2)
시간 복잡도가 선택 정렬(selection sort), 버블 정렬(bubble sort)와 동일한 이유는 최악의 경우(정렬이 엉망인 경우)에는 연산이 많아지기 때문이다.  
하지만 정렬이 잘 되어 있는 경우는 가장 연산이 적게 일어나고 자원을 적게 소모하며 빠르다. 후에 나올 퀵 정렬 등과 비슷하거나 더 나은 퍼포먼스를 보여준다.  
세 정렬 중에서는 가장 효율적이다.  

효율적인 이유 : 정렬을 해야하는 특정 숫자 앞의 숫자들은 정렬이 완료된 상태이기 때문에 전체를 비교하지 않고 해당 숫자의 왼쪽 숫자부터 비교하면서 큰 값이 왼쪽에 있으면 위치를 바꿔주면 됨.  
> 1 5 7 8 10 6 .. 에서는 6을 10부터 7까지 3번만 비교하면서 위치를 바꿔주면 1 5 6 7 8 10 .. 으로 정렬됨.

