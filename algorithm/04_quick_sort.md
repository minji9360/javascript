## 퀵 정렬의 핵심
대표적인 분할 정복 알고리즘이다.  
특정 값을 기준으로 큰 숫자와 작은 숫자를 나눈다.

## 예시
3 7 8 1 5 9 6 10 2 4  
위 숫자들을 오름차순으로 정렬하라  

## 진행
1. 보통 첫 번째 원소가 기준 값(= 피벗 값 Pivot)으로 설정된다.
2. 왼쪽에서 오른쪽으로 가며 피벗 값보다 큰 값을 찾고, 오른쪽에서 왼쪽으로 오며 피벗 값보다 작은 값을 찾는다.  
> 큰 값 : 7, 작은 값 : 2  
3. 큰 값과 작은 값의 위치를 바꾼다.  
> (3) 2 8 1 5 9 6 10 7 4
반복하면  
> (3) 2 1 8 5 9 6 10 7 4
4. 큰 값과 작은 값을 찾는다.
> 큰 값 : 8, 작은 값 : 1
5. 작은 값의 인덱스가 큰 값의 인덱스보다 작을 경우(엇갈린 경우), 작은 값과 가장 왼쪽의 값의 위치를 바꾼다.  
(이제 3은 정렬이 완료되었고 3의 왼쪽은 3보다 작은 수, 3의 오른쪽은 3보다 큰 수의 집합이 됨 = 집합을 한 번 분할)
> 1 2 <b>3</b> 8 5 9 6 10 7 4
　1회전 후에는 기준 값 왼쪽은 기준 값보다 작고, 오른쪽은 기준 값보다 크다.
6. 작은 값의 집합과 큰 값의 집합 각각에서 첫 번째 수가 피벗 값이 된다.
> (1) 2 <b>3</b> (8) 5 9 6 10 7 4
7. 작은 값의 집합과 큰 값의 집합에서 각각 정렬을 수행한다.
8. 작은 값의 집합에서 정렬
> 큰 값 : 2, 작은 값 : 1 (없으므로 자기 자신을 고름)  
> 엇갈렸으므로 1과 자기 자신의 위치를 바꾼다.  
> <b>1</b> 2 <b>3</b>
> 큰 값을 기준으로 피벗을 수행  
> <b>1</b> (2) <b>3</b>  
> 데이터가 2밖에 없으므로 확정  
> <b>1 2 3</b>
9. 큰 값의 집합에서 정렬
> 큰 값 : 9, 작은 값 : 4  
> (8) 5 4 6 10 7 9  
> 큰 값 : 10, 작은 값 : 7
> (8) 5 4 6 7 10 9  
> 큰 값 : 10, 작은 값 : 7  
> (7) 5 4 6 <b>8</b> (10) 9  
> 또 양 옆의 집합들을 각각 정렬 반복

## 시간 복잡도 : O(N * logN)
잘게 쪼갠 후, 각자 정렬하고 다시 합치기 때문에 훨씬 적은 수만큼의 연산을 하게 된다.  
데이터의 개수 N과 큰 수와 작은 수의 집합으로 계속해서 반 씩 나눈다는 의미에서 log₂N이라고 볼 수 있다.
> 1 2 3 4 5 6 7 8 9 10  
> 선택 정렬 : N ^ 2 = 10 * 10 = 100  
> 1 2 3 4 5 / 6 7 8 9 10  
> (5 * 5 = 25) + (5 * 5 = 25) = 50  

